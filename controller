우리가 작성할 controller
boardcontroller
작성해야할 기능 목록
전체 목록 요청 /board/list GET
등록 처리 /board/register POST
조회/board/get GET
삭제/board/remove POST
수정/board/modify POST

페이징 처리
페이징처리를 하려면 sql을 변경해야 되는데 필요한 파라미터가 뭐뭐있을가
페이지번호(pageNum)    , 한페이지당 몇개의 데이터를 보여줄지(amount) = 10
1페이지 1~10 (page-1)*amount < rownum <= pageNum * amount
2페이지 11~20
--> 클래스로 관리를 합니다.

<![CDATA[ SQL구문]]>
SQl구문안에 특수문자가 들어갈경우 XML 파일에서 잘못 인식하는 경우를 막기위해 사용하는 처리방법
(Character Data 줄임말) sql 구문안에 부등호같은 특수문자가 들어갈때 사용
xml 태그만들때 <select> where bno >0

화면밑에 페이지 번호를 표시, 페이지 번호를 클릭할수 있게
<1 2 3 4 5>

페이지처리할때 필요한 정보들
현재페이지번호(pageNum)
이전과 다음으로 이동가능한 링크를 표시(prev,next)
화면에서 보여지는 페이지의 시작, 마지막(start , end)

사용자가 5페이지를 보고잇다. -> 1~10페이지
사용자가 19페이지를 보고있다. 11~20페이지
< 1 2 3 4 5 6 7 8 9 10> start: 1/ end:10
페이지 끝번호 계산
 endpage: (int)Math.ceil(현재페이지번호/10.0))*10;
현재페이지 1: Math.ceil ( 1/10.0 =0.1) = 1 *
현재페이지 10 : 10/10.0 1.0 =10
현재페이지 11 : 11/10.0 1.1 2*10 =20

페이지 시작번호
페이지 끝번호 계산후 -9
startpage= endpage-9
 끝번호는 전체 데이터수 (total)의 영향을 받는다.
진짜 끝번호를 realend
realend:(int)(Math.ceil((total * 1.0)/amount))
if (realend<endPage){
페이지끝번호를 realend로 쓴다.
}

현재페이지10 다음페이지로가면11
total 130개
realend 13
endpage 10
realend가 현재 endpage보다 크면 다음페이지로 갈수 이싸.
realend가 현재 endpage보다 작으면 못간다.

이전 페이지/ 다음 페이지
이전 페이지: 현재 페이지 -1(시작 페이지 번호가 1보다 큰 경우만)
다음 페이지: 현재페이지 +1(현재 페이지가 realend보다 작을때만)

검색기능 : sql
제목/내용/작성자

검색결과 여러개 나올수있다
여러개가 나오면==> 여러개 200만개
제목 + 내용

Mybatis를 통해 검색 sql을 작성

검색 조건이 상황에 다라 다르다
사용자가 제목검색을 한 경우 where title like '%키워드%'
사용자가 내용검색을 한 경우 where content like '%키워드%'
사용자가 제목 + 내용 검색을 한경우

Mybatis의 동적 sql (jtsl 태그랑 비슷함)
if , choose, trim, foreach
if는 test 라는 속성과 함께 특정한 조건이 true가 되었을때
포함된 sql을 사용하고자 할대 작성
예를 들어서 우리가 단일항목으로 제목검색을 하는 상황/ 내용 / 작성자
검색 조건이 T면 제목검색을 할것이다.
검색 조건이 c 면 내용검색을 할것이다.
검색 조건이 W 면 작성자 검색을 할것이다.
<if test="type == 'T'.toString()">
   (title like '%'||#{}||'%')
<if test="type == 'C'.toString()">
   (content like '%'||#{keyword}||'%')
</if>
choose 는 여러 상황들중 하나의 상황에서만 동작합니다. if-else, jstl의<choose>
<choose>
   <when test="type == 'T'.toString()">
   (title like '%'||#{keyword}||'%')
   </when>
   <when test="type == 'C'.toString()">
   (title like '%'||#{keyword}||'%')
   </when>
   <otherwise>
   위에서 아무 조건도 해당되지 않았을때..
   </otherwise>
</choose>
sql 작성을 하는데 bno라는 값이 null 이 아니면 where절을 ㅜ가해서 bno값을 비교하고싶다
select * from tbl_board bno = #{bno}
<where>
   <if test="bno !=null">
      bno = #{bno}
   </if>
</where>
태그안쪽 sql문이 생성되면 앞에 where구문이 붙고, 그렇지 않으면 생성되지않는다.
bno 값이 존재하는 경우 : select * from tbl_board where bno=xxx;
bno 값이 null인경우 : select * from tbl_board

where 절안에 and 나 or로 조건을 추가하고 싶을 경우
where bno=xxx and rownum <=10;
<trim> 태그 

<trim prefix="and">
   rownum <= 10
</trim>
and rownum <= 10
prefix, suffix, 속성 사용 가능

<foreach> List, 배열 , 맵 등을 이용해서 반복처리 할때 사용하는 태그
</foreach>

getListWithPaging --> 검색 결과 리스트
(검색조건이 없는경우는 1페이지씩 가져온다.)
(검색조건이 있는경우 페이지수 계산을 해야하는데 이때 페이지수는 총 페이지수가 아니라
검색 결과에 대한  페이지수를 계산(
200건
제목에 "새로" 가 포함된 게시물은 80건
페이지수는 한페이지에 10개씩이라고 하면 8페이지

트랙잭션관리
쪼개질수 없는 하나의 작업 단위 : 트랙잭션
ACID
A Atomicity 원자성
   하나의 트랜잭션은 모두 하나의 단위로 처리 되어야한다.
   하나의 트랜잭션안에 a b 이 두작업이 포함되어 있는 경우
   a는 성공했지만 b는 실패할경우 전체가 실패한것으로 간주하고 원래 상태도 되돌린다.
   a와 b의 실행결과를 동일않 결과로 한다.
   두개다 모두성공
   두개다 모두 실패
C consistency 일관성
   트랜잭션이 성공했다면 데이터베이스의 모든 데이터는 일관성을 유지해야 한다.
   트랜잭션으로 처리된 데이터와 다른데이터 사이에 전혀 차이가 없어야한다.
I isolation 격리성
  트랜잭션이 처리되는 중간에 외부에서 간섭할수 없다.
 D durability 영속성
     트랜잭션이 성공적으로 처리되면 그결과는 영속적으로 보관
     
정규화 : 중복된 데이터를 제거해서 데이터 저장의 효율을 올린다.
중복된 데이터를 제거??????

person
이름, 주민번호, 주소 , 성별 ...
홍길동 00-000 서울 남
student
이름 , 학번 ,주민번호 ,주소 ,성별
홍길동07 00-000 서울 남

student

학번, 주민번호, ...
07, 00-000, ...

테이블의 조인을 이용해서 주민번호 컬럼(왜래키)을 이용해서 그사람의
다른테이블에 있는 정보를 가져온다.
where student.주민번호 = person.주민번호
정규화가 진행될수록 테이블은 점점 더 순수한 형태가 되어간다.(꼮 필요한 정보만 저장)

데이터를 조회할때 사람의 이름만 가져오면 상관 없는데 이름 주소 성별을 다가져와야 할때
person_name.주민번호=person_address.주민번호 = person_gender.

테이블을 조인한다 ?? 컴퓨터가 조인이 필요한 테이블을 검색
컴퓨터가 할일이 너무 많아짐 => 시간도오래걸림 성능저하

다시 테이블을 합쳐서 하나의 테이블에서 검색할수 있도록(조인회수줄인다)
반정규화(어느정도 중복을 허용한다 대신 조인, 서브쿼리 이용회수를 줄임.)

스프링에서 트랜잭션 기능을 제공
spring-tx , spring-jdbc, ojdbc

트랜잭션 기능을 사용하기 위해 필요했던 설정들
pom.xml
spring-tx, spring-jdbc, ojdbc
+ aop (aspectjrt, aspectjweaver)
의존성 추가
스프링 설정파일
db 관련 설정빈 (data source, sqlSessionFactory)
transsactionManager빈 추가
<tx:annotation-driven /> : 트랜잭션 설정을 어노테이션으로 하겠다
<aop:aspectj-autoproxy> :aop 서정을 어노테이션으로 하겠다.
우리가 사용할 메소드 (트렌젝션 처리하고 싶은 메소드) 위에 @Transactional



REST 방식으로 전환
옛날방식에서는 우리가 만드는 데이터의 소비자가 웹 브라우저 (컴퓨터)
스마트폰(모바일)
서버의 데이터를 소비하는 주제가 웹 브라우저라는 특정한 어플리케이션
==> 모바일기기가 많아지면서 모바일의 앱이나 웹도 서버에서 제공하는 데이터를 소비하게 되었다.

과거의 서버의 데이터 제공 대상 : 웹 브라우저
최근 서버의 데이터 제공대산 : 웹브라우저 + 수많은 다양한 기기들 (스마트폰)

스마트폰이 APP이라고 불리는 고유한 어플리케이션을 사용해서 데이터를 소비
스마트폰에 보이는 화면은 더이상 HTML이 아니다 (자신만의 방법으로 화면을 제공)	

REST (Repersentational State Transfer)
하나의 URI는 하나의 고유한 RESOURCE(자원)을 대표하도록 설계
URI: 당신이 원하는곳의 주소는 여기입니다.
URL: 이곳에 오면 당신이 원하는 것을 찾을수 있습니다.
"/board/123" 이 주소는 123번 게시물을 위한 유일한 주소
+ GET/POST 데이터를 전달하는 방식까지 추가

REST = URI + GET/POST/PUT/DELETE/......

REST 방식이 되면 가장 먼저 기억해야하는것 : 서버의 변화
서버가 전송하는것이 순수한 데이터가 된다
기존의 컨트롤러에서 데이터를 담아서 JSP와 같은 VIEW로 전달하는 방식이 아니다.	

서버가 순수하게 데이터만 전달한다 ==> 많이 사용하는 방식
JSON타입으로 데이터를 전달한다.
XML 방식(옛날)


파일 업로드

첨부파일 설정은 프로젝트에 web.xml 이 있는경우 web.xml 에서 처리해준다.
스프링 사용시에는 MultipartResolver라는 타입의 객체를 빈으로 등록해서 사용
web 과 관련된 설정이므로 servlet-context.xml을 이용해서 빈으로 등록